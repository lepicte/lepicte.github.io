<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      XSS, CORS, CSRF (Partie 3) &middot; Lanyon
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/web/2016/08/20/xss-cors-csrf-partie-3-cors-csrf/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" checked>

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A reserved <a href="https://jekyllrb.com" target="_blank">Jekyll</a> theme that places the utmost gravity on content with a hidden drawer. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

    <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Lanyon</a>
            <small>A Jekyll theme</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">XSS, CORS, CSRF (Partie 3)</h1>
  <span class="post-date">20 Aug 2016</span>
  <h2 id="les-requêtes-cross-site">Les requêtes Cross-Site.</h2>

<p>Bienvenue dans ce dernier volet de notre Saga XSS (<a href="http://localhost:4000/xss-cors-csrf-partie-1-xss">partie 1</a>, <a href="http://localhost:4000/xss-cors-csrf-partie-2-xss-cookies-session">partie 2</a>).</p>

<p>Dans notre précédent article nous avions récupéré un cookie de session insuffisamment sécurisé grâce à une vulnérabilité XSS. Vous étiez nombreux dans ma tête à me demander pourquoi ce message d’erreur (ici Chrome mais le fonctionnement est identique sous IE, Firefox) :</p>

<pre class="alert">
XMLHttpRequest cannot load http://requestb.in/w7iy5sw7?cookie=PHPSESSID_unsecured=jm5mah0a9uuf4g344096nled73. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost' is therefore not allowed access.
</pre>
<p><br />
Alors que nous avions bien réceptionné notre requête sur requestb.in :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_1.png" alt="Cross-Origin simple" /><br />
Et bien nous sommes dans le cas d’une <strong>requête simple Cross-origin</strong> :</p>

<blockquote>
  <p><em>Le Cross-origin resource sharing (CORS) est un mécanisme qui permet à des ressources restreintes d’une page web d’être requêtées par un autre domaine que celui de la ressource en question</em>.</p>
</blockquote>

<p>Comme stipulé sur le site de Mozilla :</p>

<p><em>Le standard de partage de ressources d’origines croisées fonctionne grâce à l’ajout d’entêtes HTTP qui permettent aux serveurs de décrire l’ensemble des origines permises. C’est ensuite le navigateur qui lit cette information et en fait l’usage adéquat. Par ailleurs, pour les requêtes HTTP dont les méthodes pourraient avoir des effets secondaires sur les données utilisateur (non idempotentes - en particulier pour les méthodes HTTP autres que GET, ou pour l’utilisation du POST avec certains types MIME), la spécification mandate les navigateurs de “pré-vérifier” la requête en sollicitant le serveur pour connaître les méthodes approuvées. Cette pré-vérification s’effectue avec la méthode HTTP OPTIONS, et ensuite, après “approbation” du serveur, envoie la requête véritable. Les serveurs peuvent aussi notifier les clients des informations pouvant être associées aux requêtes cross-origin (incluant les cookies et les données d’authentification HTTP).</em></p>

<p>Dans notre exemple de requête simple cross-origin, le domaine de la ressource ayant initié la requête (<strong>http://localhost:80</strong>) étant différent du domaine requêté (<strong>http://requestb.in:80</strong>), notre navigateur détecte une requête <strong>CORS</strong> (l’origine est représentée par <strong>protocole://domaine:port</strong>). Pour connaitre le comportement à adopter, le navigateur attend dans la réponse un header <strong>Access-Control-Allow-Origin</strong> qui nous informe sur l’autorisation d’accès ou non à la ressource. Le comportement par défaut en l’absence d’un tel header est de considérer l’opération comme <strong>DONE</strong> (xhr.readyState == 4) mais de retourner un statut <strong>UNSENT/OPENED</strong> (xhr.status == 0). Nous ne pourrons donc pas accéder au contenu de notre réponse.</p>

<p>Cependant nous remarquons que sans filtre explicite coté serveur et en déléguant la sécurité au navigateur (absence par défaut du header Access-Control-Allow-Origin), la requête a été correctement traitée coté serveur. Ceci ne sera pas le cas avec les requêtes pré-vérifiées.</p>

<p><strong>Requête simple</strong> :</p>

<p>Une requête cross-site simple est une requête qui:</p>

<ul>
  <li>Utilise les méthodes HTTP GET, HEAD ou POST. Si POST est utlisé pour envoyer des données au serveur le Content-Type des données envoyé au serveur est soit application/x-www-form-urlencoded, multipart/form-data, ou text/plain.</li>
  <li>Ne positionne pas d’entêtes personnalisés avec la requête HTTP Request (comme par exemple X-Modified, etc.).</li>
</ul>

<p><strong>Requête pré-vérifiée</strong> :</p>

<p>Une requête est prévérifiée si :</p>

<ul>
  <li>Elle utilise des méthodes autres que GET, HEAD ou POST.  Aussi, si POST est utilisée pour envoyer des requêtes de données avec un Content-Type autre que application/x-www-form-urlencoded, multipart/form-data, ou text/plain, par exemple si la requête POST envoie au serveur un contenu utile XML en utilisant application/xml ou text/xml, alors la requête est pré-vérifiée.</li>
  <li>Elle positionne des entêtes propres (ex: la requête utilise une entête comme X-PINGOTHER).</li>
</ul>

<p>Vous trouverez un très bon exemple de requête CORS préflight <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Requ.C3.AAtes_pr.C3.A9-v.C3.A9rifi.C3.A9es">ici</a>.</p>

<p>Le serveur nous retournera tous les headers nécessaires pour informer le client des autorisations Cross-Origin. Encore une fois inutile de faire du copier/coller, vous trouvez la liste de ces headers response <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Les_ent.C3.AAtes_HTTP_de_r.C3.A9ponse">ici</a>. Certains <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Les_ent.C3.AAtes_HTTP_de_la_requ.C3.AAte">request headers</a> sont automatiquement positionnés par le navigateur.</p>

<p>Vous ne pourrez pas agir sur les request headers CORS, si vous tentez ce genre d’opérations :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Origin</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">http://requestb.in</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Referer</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">http://requestb.in/11hlgzo1</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>
<p>Vous aurez un joli message sous Chrome et le navigateur positionnera lui-même ces entêtes (comportement identique sous Firefox et IE, seuls les messages d’erreur diffèrent):</p>
<pre class="alert">
Refused to set unsafe header "Origin"  
Refused to set unsafe header "Referer"  
</pre>
<p><br />
La première chose pour un site souhaitant faire du CORS est de bien positionner les origines autorisées avec le header <strong>Access-Control-Allow-Origin</strong>. Ce dernier doit stipuler explicitement les origines autorisées pour bénéficier pleinement de l’utilisation des XHR (rappelons que l’utilisation de ces headers concernent les XmlHttpRequest, une iframe par exemple n’émettra pas de header Origin et sera soumise à la <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Changing_origin">Same Origin Policy</a>).</p>

<p>Cependant <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin: *</code> : toutes les origines peuvent accéder à la ressource. La restriction concernant l’utilisation du wildcard est que les réponses des requêtes XHR <strong>withCredentials</strong> ne pourront pas être lues pour des raisons de sécurité, <strong>même si le serveur positionne le header <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials: true</code></strong>. Imaginons que toutes les conditions soient remplies; un pirate pourrait coder depuis son site (ou à partir d’une XSS) une succession de requêtes cross-origin incluant les credentials de l’utilisateur et effectuer des actions à son insu (la lecture des réponses withCredentials implique donc une origine explicitement autorisée par le serveur et un Access-Control-Allow-Credentials: true):</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_2.png" alt="Schema attaque CORS" /></p>

<p>Comme nous l’avons vu, en l’absence de ce header, le navigateur bloquera l’accès à la réponse. Cependant cette <strong>requête simple CORS POST <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a></strong> sera interprétée sur le serveur si ce dernier ne possède pas de filtre CORS explicite (à partir d’un site malicieux, les requêtes GET, POST générées à partir d’éléments HTML enverront le cookie dans la requête. Sur de l’Ajax il faut rajouter la clause withCredentials = true).</p>

<p>Pour cet exemple, nous avons créé une page <strong>http://localhost/secu/cookie.html</strong>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
	<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://requestb.in/11hlgzo1</span><span class="dl">'</span><span class="p">);</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">op=exaction</span><span class="dl">'</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Au préalable nous nous sommes connectés sur <strong>requestb.in</strong>. Ce site initialise plusieurs cookies dont le suivant :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_3.png" alt="Cookie requestb.in" /><br />
Nous remarquons un cookie sécurisé, donc impossible d’y accéder via <strong>document.cookie</strong>. Cependant <strong>withCredentials</strong> inclut automatiquement les cookies dans la requête (<em>Update 14/05/2017: validé à nouveau sur Chrome v56, cependant le comportement n’est pas reproductible sur ma Kali sur des versions Firefox ESR v45.3 et Chromium v53</em>).</p>

<p>Vérifions l’éxecution du payload sur request.bin :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_4.png" alt="Résultat request.bin" /><br />
Un petit tour du côté de la console :</p>
<pre class="alert">
XMLHttpRequest cannot load http://requestb.in/11hlgzo1. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost' is therefore not allowed access
</pre>
<p><br />
Et de la réponse :</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Sat, 20 Aug 2016 14:41:21 GMT</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=utf-8</span>
<span class="na">Sponsored-By</span><span class="p">:</span> <span class="s">https://www.runscope.com</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">session=eyJyZWNlbnQiOlsiMTFobGd6bzEiLCIxNzRzOGR3MSJdfQ.Cpn9kQ.ouuFFtBlOyU9cX5aymJeDrg57gQ; HttpOnly; Path=/</span>
<span class="na">Via</span><span class="p">:</span> <span class="s">1.1 vegur</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">cloudflare-nginx</span>
<span class="na">CF-RAY</span><span class="p">:</span> <span class="s">2d569b0e05cb0914-CDG</span>
<span class="na">Content-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
<span class="na">Transfer-Encoding</span><span class="p">:</span> <span class="s">chunked</span>
</code></pre></div></div>

<p>L’objet de cette attaque est donc de transmettre à un utilisateur authentifié une requête HTTP falsifiée qui pointe sur une action interne au site (www.site-de-confiance.com), afin qu’il l’exécute sans en avoir conscience et en utilisant ses propres droits. Il s’agit d’une attaque <strong>Cross-Site Request Forgery</strong>. Ici nous n’utilisons pas de faille XSS car tout se passe sur le site du pirate.</p>

<p><strong>Comment éviter ce type d’attaque CSRF?</strong></p>

<p>L’application doit positionner dans les formulaires un <strong>jeton aléatoire unique</strong> non prédictible par l’assaillant (nonce). Ainsi lors d’une soumission sur www.site-de-confiance.com, le serveur vérifiera si ce jeton est présent et si il est valide. Demandez également des confirmations sur vos actions critiques (exemple demande de l’ancien mot de passe si ce dernier doit être changé).</p>

<p>Vous trouverez sur <a href="https://github.com/phackt/DemoWebApp">https://github.com/phackt/DemoWebApp</a> la protection <strong>CSRF</strong> activée par défaut avec <strong>Spring Security</strong>. Je vous recommande de lire la <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html">documentation</a> si vous utilisez ce framework dans votre web app Java.</p>

<p>Voici par exemple ce qui est généré dans un formulaire :</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">id=</span><span class="s">"idFilesUploadForm"</span> <span class="na">action=</span><span class="s">"uploadFile"</span> <span class="na">method=</span><span class="s">"POST"</span> <span class="na">enctype=</span><span class="s">"multipart/form-data"</span><span class="nt">&gt;</span>
	...
	<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"_csrf"</span> <span class="na">value=</span><span class="s">"400a3ca2-4a8e-4c2e-b248-9d60a0e112b5"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>Vous vous demandez peut être si nous pouvons contourner ce token sur un site vulnérable au XSS. Rappelez-vous notre <a href="http://localhost:4000/xss-cors-csrf-partie-2-xss-cookies-session#iframe">payload</a> dans notre précédent article et le response header <strong>X-Frame-Options</strong>… Si cet header est absent rien ne nous empêche sur le site www.site-de-confiance.com de charger notre page dans une <strong>iframe</strong>, de récupérer le token et de le soumettre pour effectuer une action malveillante.</p>

<p>Il est également important de définir une politique CORS <strong>coté serveur</strong>. Nous pouvons tout simplement renvoyer un code <code class="language-plaintext highlighter-rouge">403 – Forbidden</code> pour les cross-origin en implémentant un <strong>CORS Filter</strong>. A partir de Tomcat 7 vous pouvez utiliser le filtre <a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html#CORS_Filter">CorsFilter</a> dans votre chaine de filtres (fichier web.xml) :</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;filter&gt;</span>
	<span class="nt">&lt;filter-name&gt;</span>CorsFilter<span class="nt">&lt;/filter-name&gt;</span>
	<span class="nt">&lt;filter-class&gt;</span>org.apache.catalina.filters.CorsFilter<span class="nt">&lt;/filter-class&gt;</span>
	<span class="nt">&lt;init-param&gt;</span>
		<span class="nt">&lt;param-name&gt;</span>cors.allowed.origins<span class="nt">&lt;/param-name&gt;</span>
		<span class="nt">&lt;param-value&gt;</span>http://mondomain<span class="nt">&lt;/param-value&gt;</span>
	<span class="nt">&lt;/init-param&gt;</span>
<span class="nt">&lt;/filter&gt;</span>
<span class="nt">&lt;filter-mapping&gt;</span>
	<span class="nt">&lt;filter-name&gt;</span>CorsFilter<span class="nt">&lt;/filter-name&gt;</span>
	<span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/filter-mapping&gt;</span>
</code></pre></div></div>

<p>Vous trouvez le flowchart du filtre <a href="http://tomcat.apache.org/tomcat-8.0-doc/images/cors-flowchart.png">ici</a>.
<strong>Ceci interdit donc en amont l’accès à toute requête cross-origin.</strong></p>

<p><strong>Quid des frameworks pour développer des clients riches comme Angular ou React</strong> ?<br />
Au vu de la multiplicité des requêtes asynchrones, il convient de positionner un token CSRF unique (à éviter en tant que cookie car devra être en httpOnly pour des requêtes xhr), et de rajouter ce token en tant que header (exemple X-XSRF-TOKEN: a0ed8d95-5694-4b77-853c-b04677677722) dans la requête, header qui sera vérifié coté serveur. Cet en-tête non standard permet également le déclenchement d’une requête préliminaire (OPTIONS) pour vérifier si l’origine de la requête est autoriséé.<br />
<br />
<strong>Conclusion :</strong></p>

<p>Nous avons vu que les vecteurs d’attaques sont multiples sur les applications Web. Vous devez mettre en place toutes les mesures pour sécuriser les sessions de vos utilisateurs (assainissement des input, response headers de sécurité, sécurisation des cookies, token CSRF, bannissement du CORS côté serveur). Eprouvez votre application avec les outils nécessaires (<a href="https://www.owasp.org/index.php/OWASP_Xenotix_XSS_Exploit_Framework">Xenotix</a>), regardez quels sont les headers envoyés et reçus directement dans votre navigateur ou grâce à un proxy comme <a href="https://portswigger.net/burp/">Burp Suite</a> ou <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">Owasp ZAP</a>.</p>

<p>Nous verrons dans un prochain article comment utiliser les techniques vu précédemment dans une attaque Man In The Middle. Imaginez qu’un pirate se positionne entre vous et le site web : toutes les protections abordées précédemment seront indispensables pour éviter l’interception en clair de votre trafic et le vol de vos sessions. Pensez à l’injection d’un payload Javascript dans une ressource quelconque non sécurisée qui effectuerait une requête <strong>cross-site withCredentials</strong> sur du <strong>HTTP</strong> (non over SSL - ceci possible si cookie avec le flag <strong>Secure</strong> absent)…</p>

<p><a name="hsts"></a>C’est à ce niveau que le response header <a href="https://https.cio.gov/hsts/">HSTS</a> est primordial, car une ressource en cache dans le navigateur ayant le HSTS de positionné indiquera au navigateur que toute requête sur le domaine de cette ressource fera l’objet d’une redirection interne (307 Internal Redirect). Nous aborderons ce cas pratique identifié sur un site pour montrer que la protection HSTS est ici le dernier recours au vol de session lors d’une attaque MITM si le cookie n’est pas sécurisé (flag <strong>Secure</strong>). Ceci nous prouve que chaque protection doit être mise en place pour contrecarrer toutes les combinaisons d’attaques.</p>

<p>A bientôt.
<br />
<br />
Références :<br />
<a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS">https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS</a><br />
<a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a><br />
<a href="https://fr.wikipedia.org/wiki/Cross-Site_Request_Forgery">https://fr.wikipedia.org/wiki/Cross-Site_Request_Forgery</a><br />
<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html">https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html</a></p>

</div>


<div class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/dev/2020/05/27/git-secrets-exposed/">
            What solutions to prevent git leaks ?
            <small>27 May 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/web/2018/08/05/web-exposed-git-repositories/">
            Gathering some information from web exposed git repositories
            <small>05 Aug 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/web/2017/12/24/play-with-permissive-cors/">
            Play with permissive CORS
            <small>24 Dec 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>


      </div>
    </div>


    <!-- <label for="sidebar-checkbox" class="sidebar-toggle"></label> -->

    <script src='/public/js/script.js'></script>
 
  </body>
</html>
